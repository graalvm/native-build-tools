= End-to-end Native Gradle Plugin guide
The GraalVM team
:highlighjsdir: {gradle-relative-srcdir}/highlight


This guide leads you through the process of integrating Native Gradle Plugin with your project.
It starts from adding the plugin to your project, goes through some of the main functionalities that you may use (like collecting the metadata),
all the way to some diagnostics tools that you can use to analyse native executables you have made.
You can see an example of tests on which we tested whole guide <<example,here>>.

In case you only want to see how a simple application works in practise, you can check <<quickstart-gradle-plugin.adoc#,our demo>>.

[[prerequisites]]
== Prerequisites

- Before starting, make sure that you have GraalVM installed locally. You can https://www.graalvm.org/downloads/[download Oracle GraalVM from the official website].
- In most cases you can run your Gradle project with almost any GraalVM version. All you have to do is to set `JAVA_HOME` environment variable to the release you want to use.

[WARNING]
Note that in some cases, depending on the Gradle version you are using (https://docs.gradle.org/current/userguide/compatibility.html[see compatibility matrix]), you may not be able to run your project just by setting `JAVA_HOME` environment variable.
You can run Gradle project with any Java version you want (for example Java 17), but you should set `GRAALVM_HOME` environment variable to point to whatever GraalVM release you need (for example GraalVM 23).
This way, the Gradle plugin will build itself with Java specified in `JAVA_HOME` and your project with the version specified in `GRAALVM_HOME`.

[[adding-plugin]]
== Adding the GraalVM Native Plugin

In order to use Native Image with Gradle you must add the following block into your `build.gradle` file inside `plugins` block:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
  id 'org.graalvm.buildtools.native' version '{gradle-plugin-version}'
----

[source,kotlin,subs="verbatim,attributes",role="multi-language-sample"]
----
  id("org.graalvm.buildtools.native") version "{gradle-plugin-version}"
----

Older versions of the plugin are listed https://github.com/graalvm/native-build-tools/releases[here]

[[run-your-project]]
== First runs of your project

This plugin works with the application plugin and will register a number of tasks that you may want to execute.
The main tasks you may want to use are:

- `nativeCompile` - triggers the generation of a native executable of your application
- `nativeRun` - executes the generated native executable
- `nativeTestCompile` - builds a native image with tests found in the test source set
- `nativeTest` executes tests found in the test source set in native mode

In the following sections you will find out how to use these tasks in practice.


[[run-on-jvm]]
==== Run on JVM

Note that **if you want to run your application (or maybe the native image agent later on your application) on the JVM** you should make the following changes in the `build.gradle`:

- replace `java` plugin with the `application` plugin in the plugins section
- add the following block which will tell the application where is the main entry point:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
application {
    mainClass = "org.example.Main"
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
application {
    mainClass.set("org.example.Main")
}
----

- you can remove `mainClass = "org.example.Main"` from the `binaries.main` block
- from now on, you will be able to execute your main application on the JVM as well with the

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew run
----

[TIP]
Note that the snippet above points to the main class placed under __/src/main/java/org/example/Main.java__. You should adjust this according to your application sources.

[[run-tests]]
=== Run your tests

Running your tests should be a straightforward.
All you have to do is to write your tests under the test source (usually under __/src/test/java/__) and run

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew nativeTest
----

[[run-application]]
=== Run your application

You can try to build native image on a simple HelloWorld application (or with your custom entry point if you are not starting from the scratch).
To build your main application add the following block into `build.gradle`:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    graalvmNative {
        binaries.main {
            imageName = "main"
            mainClass = "org.example.Main"
        }
    }
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    graalvmNative {
        binaries.main {
            imageName.set("main")
            mainClass.set("org.example.Main")
        }
    }
}
----

and run
[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew nativeCompile
----

This command will trigger native image build.
Once the build is finished, run the following command to execute generated Native Image.
[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew nativeRun
----

[[configuration-options]]
== Providing configuration options

The main configuration point of this plugin is the `graalvmNative` block that you added into `build.gradle` file.
You can apply configuring options specific to the main or the test binary (or you can provide options that applies to all binaries) like following:


[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    binaries.main {
        // options you want to pass only to the main binary
    }
    binaries.test {
        // options you want to pass only to the test binary
    }
    binaries.all {
        // common options you want to use for both main and test binaries
    }
}
----

Inside these blocks you can pass the following options:

- `imageName` -The name of the native image (defaults to the project name)
- `mainClass` - The main class to use, defaults to the application.mainClass
- `debug` - Determines if debug info should be generated, `false` by default (alternatively add --debug-native to the CLI)
- `verbose` - Add verbose output (`false` by default)
- `fallback` - Sets the fallback mode of native-image (`false` by default)
- `sharedLibrary` - Determines if image is a shared library (`false` if the `application` plugin is applied, `true` if the `java-library` plugin is applied)
- `quickBuild` - Determines if image is being built in quick build mode
- `richOutput` - Determines if native-image building should be done with rich output
- `systemProperties` - Sets the system properties to use for the native image builder
- `configurationFileDirectories` - Adds a native image configuration file directory, containing files like reflection configuration
- `excludeConfig` - Excludes configuration that matches one of given regexes from JAR of dependency with said coordinates.
- `jvmArgs` - Passes the given argument directly to the JVM running the native image builder
- `useFatJar` - Instead of passing each jar individually, builds a fat jar

You can also pass **build-time** and **run-time** arguments:

- `buildArgs.add('<buildArg>')` - You can find more about possible build arguments https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/[here] and https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/[here]
- `runtimeArgs.add('<runtimeArg>')` - Runtime arguments consumed by your application

Here is an example of additional options usage:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    binaries.main {
        imageName = 'application'
        mainClass = 'org.test.Main'
        fallback = true
        sharedLibrary = false
        richOutput = false

        systemProperties = [name1: 'value1', name2: 'value2']
        configurationFileDirectories.from(file('src/my-config'))

        buildArgs.add('--link-at-build-time')
        runtimeArgs.add('--help')

        jvmArgs.add('flag')
        useFatJar = true
    }

    binaries.test {
        debug = true
        verbose = true
    }

    binaries.all {
        quickBuild = false
    }
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    binaries.main {
        imageName.set('application')
        mainClass.set('org.test.Main')
        fallback.set(true)
        sharedLibrary.set(false)
        richOutput.set(false)
        requiredVersion.set('22.3')

        systemProperties.putAll(mapOf("name1" to "value1", "name2" to "value2"))
        configurationFileDirectories.from(file('src/my-config'))

        buildArgs.add('--link-at-build-time')
        runtimeArgs.add('--help')

        jvmArgs.add('flag')
        useFatJar.set(true)
    }

    binaries.test {
        debug.set(true)
        verbose.set(true)
    }

    binaries.all {
        quickBuild.set(false)
    }
}
----

[[collect-metadata]]
== Collecting metadata

When your application starts to be more complex, additional configuration like **reflection**, **resources**, **serialization**, **proxies** or **jni** metadata may be required.
Since the Native Image has closed world assumption, all of these things must be known in advance during the image build.
The easiest way to pass this information to the Native Image is through configuration file(s) - depending on the GraalVM version you are using, there could be
a single `reachability-metadata.json` file (for newer GraalVM versions) or multiple json files (`reflect-config.json`, `resource-config.json`, `proxy-config.json`, `serialization-config.json`, `jni-config.json`).
To learn more about metadata that Native Image consumes, https://www.graalvm.org/latest/reference-manual/native-image/metadata/[see this].

For example, if you run tests which make use of reflection, and you don't have entry for reflective calls in the metadata config file, your native tests will fail.

In order to make your test/application work natively while using reflection (like in this example) or other features which require additional metadata, you should either generate configuration files or write them manually.
The easiest is to generate metadata automatically.
For this you can run your tests (or the main application) with the Native Image Agent, which will collect all the metadata your test/application require and generate metadata for you.
To enable the agent (through Native Gradle Plugin) you should either:

- add `-Pagent` flag to the command line (for example `./gradlew test -Pagent`)
- or add the following block to `graalvmNative` block in the `build.gradle`:


[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    enabled = true
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    enabled.set(true)
}
----

[.underline]#To generate the metadata file(s) for your `tests` just run:#

- `./gradlew test` if you added the agent block to the configuration or `./gradlew -Pagent test` if you didn't. This command runs on JVM with native-image-agent and collects the metadata.
- `./gradlew nativeTest` if you added the agent block to the configuration or `./gradlew -Pagent nativeTest` if you didn't. This command runs on JVM with the native-image agent, collects the metadata and uses it for testing on native-image.


[.underline]#To generate the metadata file(s) for your `application` just run:#

- `./gradlew run` if you added the agent block to the configuration or `./gradlew -Pagent run` if you didn't. This command runs on JVM with native-image-agent and collects the metadata.

[WARNING]
====
**When using `./gradlew test` to generate metadata**, the plugin will use the agent from `JAVA_HOME`.
If you define `GRAALVM_HOME`, your application will run with version defined there.
In this case you may not have appropriate metadata for the version your application uses.
To avoid potential complications, we suggest that you generate metadata with the same version your application uses.
You can achieve this by adding the following inside the `test` block in your `build.gradle`

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
executable = providers.environmentVariable("GRAALVM_HOME").map {
    "$it/bin/java"
}.get()
----

This way, generated metadata config file(s) will have format that is specified in the GraalVM version (from `GRAALVM_HOME`) you are using.
====


[[metadata-copy]]
=== Copy generated metadata to permanent location

By default, generated metadata will be placed inside `build/native/agent-output` directory.
In many cases you may want to copy generated metadata to some other location.
To do so, you can configure and run `metadataCopy` task.

==== Configure metadataCopy task

First, you can configure `metadataCopy` task by adding a new block, named `metadataCopy` inside `agent` block that you added in the previous step.
Inside this block, you can specify:

- `outputDirectories` - location where you want to copy the generated metadata
- `inputTaskNames` - specifies tasks previously executed with the agent attached (tasks that generated metadata in the last step).
- `mergeWithExisting` - specifies whether the metadata you want to copy, should be merged with the metadata that already exists on the give location, or not. This only makes sense when there is already some existing metadata, created before.

For example: you want to execute `metadataCopy` task on the metadata generated from your tests.
Your `agent` block should look like this:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    enabled = true
    metadataCopy {
        inputTaskNames.add("test")
        outputDirectories.add("src/test/resources/META-INF/native-image/org.example")
        mergeWithExisting = false
    }
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    enabled.set(true)
    metadataCopy {
        inputTaskNames.add("test")
        outputDirectories.add("resources/META-INF/native-image/org.example")
        mergeWithExisting.set(false)
    }
}
----

Explanation of the `metadataCopy` block from above:

- __inputTaskNames.add("test")__ - means that metadata we want to copy was generated with the `./gradlew test` or `./gradlew nativeTest`
- __outputDirectories.add("resources/META-INF/native-image/org.example")__ - means that we want to copy metadata into the given directory
- __mergeWithExisting = false__ - means that we don't want to merge incoming metadata with the one that already exists on the location specified in `outputDirectories` (this makes sense since we don't have metadata on the given location already)

[[execute-metadata-copy-task]]
==== Execute metadataCopy task

Once the metadata is generated and the `metadataCopy` task is configured, you can run the task with:

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew metadataCopy
----

Besides that, you can configure `metadataCopy` task through the command line as well:

[source,bash,subs="verbatim,attributes"]
----
./gradlew metadataCopy --task run   # if you used nativeRun (or just run) to collect metadata
./gradlew metadataCopy --task test  # if you used nativeTest (or just test) to collect metadata
./gradlew metadataCopy --dir <pathToSomeDirectory> # to specify the output directory
----

Here is an example of a valid `metadataCopy` usage:

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew metadataCopy --task test --dir resources/META-INF/native-image/org.example
----

[WARNING]
====
Note that **if you store generated metadata outside of the standard resources directories (e.g `src/main/resources/META-INF/native-image/...`) **, you will need to pass that location as a Native Image `buildArg` with `-H:ConfigurationFileDirectories` option.
In this case Gradle will _not_ be able to detect changes to metadata properly, which is why we recommend to use standard locations.
[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
binaries.all {
    buildArgs.add("-H:ConfigurationFileDirectories=path/to/metadata")
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
binaries.all {
    buildArgs.add("-H:ConfigurationFileDirectories=path/to/metadata")
}
----
====

[[additional-agent-options]]
=== Additional Native Image Agent options

As your project grows, you should consider configuring the agent to gain more control over the generated metadata.

First thing that you can configure is the agent mode.
There are three possible agent modes:

* `standard` - only generates metadata without any special processing (this is the default mode). No additional options available.
* `conditional` - entries of the generated metadata will be included in the Native Image only if the condition in the entry is satisfied. Consumes following options:
** `userCodeFilterPath` - specifies a filter file used to classify classes as user application classes. Generated conditions will only reference these classes See <<agent-filter-file, the following section>>
** `extraFilterPath` - (optional) extra filter used to further filter the collected metadata. See <<agent-filter-file, the following section>>
* `direct` - in this mode user configures the agent completely manually by adding all options with:
** `options.add("<option>")`

Each of the described modes has its own benefits.
For example:

- `standard` mode is a **great starting point** in your project development
- `conditional` mode is mainly aimed towards **library maintainers** with the goal of reducing overall footprint
- `direct` mode is for **experienced users** who know how to configure the agent manually

You can configure each mode (and declare the one that will be used for generating metadata) inside the `agent` block in `build.gradle` file.
Here is an example of the `agent` block with configured conditional and direct modes, where the conditional mode is set as default and will be used to generate the metadata:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    enabled = true
    defaultMode = "conditional"
    modes {
        conditional {
            userCodeFilterPath = "src/test/native-image/filters/user-code-filter.json"
        }
        direct {
            options.add("config-output-dir=src/test/resources/direct-mode-metadata")
            options.add("experimental-configuration-with-origins")
        }
    }
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    enabled.set(true)
    defaultMode.set("conditional")
    modes {
        conditional {
            userCodeFilterPath.set("src/test/native-image/filters/user-code-filter.json")
        }
        direct {
            options.add("config-output-dir=src/test/resources/direct-mode-metadata")
            options.add("experimental-configuration-with-origins")
        }
    }
}
----

If you want to **enable the agent through the command line**, you can specify in which mode you want to run it.
For example
[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew -Pagent=standard nativeTest
./gradlew -Pagent=conditional nativeTest
./gradlew -Pagent=direct nativeTest
----

[[common-agent-options]]
==== Common agent options

All the mentioned modes shares certain common configuration options like:

- callerFilterFiles
- accessFilterFiles
- builtinCallerFilter
- builtinHeuristicFilter
- enableExperimentalPredefinedClasses
- enableExperimentalUnsafeAllocationTracing
- trackReflectionMetadata

[WARNING]
**These options are for advanced usages, and you can read more about them https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/#agent-advanced-usage[here]**.

A Complete example of the agent block should look like this:

[source,groovy,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    defaultMode = "standard"
    enabled = true

    modes {
        conditional {
            userCodeFilterPath = "path-to-filter.json"
            extraFilterPath = "path-to-another-filter.json"
        }
        direct {
            options.add("config-output-dir={output_dir}")
            options.add("experimental-configuration-with-origins")
        }
    }

    callerFilterFiles.from("filter.json")
    accessFilterFiles.from("filter.json")
    builtinCallerFilter = true
    builtinHeuristicFilter = true
    enableExperimentalPredefinedClasses = false
    enableExperimentalUnsafeAllocationTracing = false
    trackReflectionMetadata = true

    metadataCopy {
        inputTaskNames.add("test")
        outputDirectories.add("src/main/resources/META-INF/native-image/<groupId>/<artifactId>/")
        mergeWithExisting = true
    }
}
----

[source,kotlin,subs="verbatim,attributes", role="multi-language-sample"]
----
agent {
    defaultMode.set("standard")
    enabled.set(true)

    modes {
        conditional {
            userCodeFilterPath.set("path-to-filter.json")
            extraFilterPath.set("path-to-another-filter.json")
        }
        direct {
            options.add("config-output-dir={output_dir}")
            options.add("experimental-configuration-with-origins")
        }
    }

    callerFilterFiles.from("filter.json")
    accessFilterFiles.from("filter.json")
    builtinCallerFilter.set(true)
    builtinHeuristicFilter.set(true)
    enableExperimentalPredefinedClasses.set(false)
    enableExperimentalUnsafeAllocationTracing.set(false)
    trackReflectionMetadata.set(true)

    metadataCopy {
        inputTaskNames.add("test")
        outputDirectories.add("src/main/resources/META-INF/native-image/<groupId>/<artifactId>/")
        mergeWithExisting.set(true)
    }
}
----


[[agent-filter-file]]
=== Reduce the amount of generated metadata

In some cases agent may include more metadata than it is actually needed. You can filter metadata using the agent filter files.
These filter files that agent consumes have the following structure:

[source,json,subs="verbatim,attributes", role="multi-language-sample"]
----
{
 "rules": [
    {"includeClasses": "some.class.to.include.**"},
    {"excludeClasses": "some.class.to.exclude.**"},
  ],
  "regexRules": [
    {"includeClasses": "regex\.example\.class.*"},
    {"excludeClasses": "regex\.example\.exclude[0-9]+"},
  ]
}
----

The process how you can pass the config files to the agent is described in the <<additional-agent-options,previous section>>.

We can see on a simple <<example, example>> how different filter files affect generated metadata.

Let's start with the simple filter file:

[source,json,subs="verbatim,attributes", role="multi-language-sample"]
----
{
  "rules": [
    {"includeClasses": "**"}
  ]
}
----

This filter file will instruct the agent to include everything, which will result in a massive configuration file.
For example this is how `reachability-metadata.json` looks like:

[source,json,subs="verbatim,attributes", role="multi-language-sample"]
----
{
  {
    "reflection": [
      {
        "condition": {
          "typeReached": "java.io.ObjectInputStream"
        },
        "type": "[Ljava.lang.Object;"
      },
      {
        "condition": {
          "typeReached": "java.io.ObjectInputStream"
        },
        "type": "java.util.LinkedHashSet"
      },
      {
        "condition": {
          "typeReached": "org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor"
        },
        "type": "org.example.NativeTests"
      },
      {
        "condition": {
          "typeReached": "org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor"
        },
        "type": "org.example.NativeTests",
        "allDeclaredFields": true
      },
      {
        "condition": {
          "typeReached": "org.junit.jupiter.engine.descriptor.ExtensionUtils"
        },
        "type": "org.example.NativeTests"
      },
      ...
    ],
    "resources": [
      {
        "condition": {
          "typeReached": "org.junit.platform.launcher.core.LauncherFactory"
        },
        "glob": "META-INF/services/org.junit.platform.engine.TestEngine"
      },
      {
        "condition": {
          "typeReached": "java.lang.ClassLoader"
        },
        "glob": "TestResource.txt"
      },
      ...
    ],
    "bundles": [],
    "jni": [
      {
        "condition": {
          "typeReached": "java.net.InetAddress"
        },
        "type": "java.lang.Boolean",
        "methods": [
          {
            "name": "getBoolean",
            "parameterTypes": [
              "java.lang.String"
            ]
          }
        ]
      }
    ]
  }
----

As you can see, there are lots of entries that you likely don't want.
They are present because the metadata was generated using tests, for example, and that the testing library was present at runtime during the agent execution pass, but in practice, your application will not use the testing library in production.
To reduce the amount of generated metadata, we will use the following `user-code-filter.json`:

[source,json,subs="verbatim,attributes", role="multi-language-sample"]
----
{
  "rules": [
    {"includeClasses": "**"},
    {"excludeClasses": "org.junit.**"},
    {"excludeClasses": "org.gradle.**"},
    {"excludeClasses": "worker.org.gradle.**"},
    {"excludeClasses": "org.slf4j.**"},
    {"excludeClasses": "java.**"}
  ]
}
----

[WARNING]
====
Always be careful when removing entries in metadata, as this may result in a broken binary.
====

After updating our filters, we can regenerate the metadata, which will result in the following `reachability-metadata.json` file:

[source,json,subs="verbatim,attributes", role="multi-language-sample"]
----
{
  "reflection": [
    {
      "condition": {
        "typeReached": "org.example.NativeTests"
      },
      "type": "org.example.NativeTests$Person",
      "allDeclaredFields": true
    },
    {
      "condition": {
        "typeReached": "sun.security.jca.GetInstance"
      },
      "type": "sun.security.provider.SHA",
      "methods": [
        {
          "name": "<init>",
          "parameterTypes": []
        }
      ]
    }
  ],
  "resources": [
    {
      "condition": {
        "typeReached": "org.example.NativeTests"
      },
      "glob": "TestResource.txt"
    }
  ],
  "bundles": []
}
----

As you can see there are no more entries that contain classes from `org.junit` (as their condition).

[[maintain-generated-metadata]]
== Maintain generated metadata

If you are a library maintainer, or if your application grows large, you may consider covering most of your code with tests.
This way you can also track if your project requires updates of the existing metadata.
Considering that you run your tests on CI, at some point (after updating some dependency or adding new feature/test) you may notice some test failures with missing resources errors or that something is reflectively missing...
In that case, your metadata requires update.

[WARNING]
Be aware that if you modified existing metadata file(s) on the default location, generating a new metadata will overwrite the existing one and your manual changes will be lost.

So if you modified existing metadata file(s) on the default location, please do the following:

1. Move your metadata to some other, non-default location (with the `metadataCopy` task for example)
2. Set `mergeWithExisting` option to true in the `metadataCopy` block
3. Run your tests again to generate new metadata (as we already described in the <<collect-metadata, collect metadata section>>)
4. Run `metadataCopy` task again (with `mergeWithExisting` set to true in step 2)

This way you will keep your original metadata, and add a new one.


[[reachability-metadata-repository]]
== Reachability metadata repository

While we have described how you can add metadata for your own code, Native Build Tools (both Gradle and Maven plugins) makes use of metadata from Reachability Metadata Repository to ensure your application works out-of-box with 3rd party libraries that you depend on.
You can configure Reachability metadata support through `metadataRepository` block added to our main `graalvmNative` block inside `build.gradle`.
Most common options you may want to configure in this block are:

* `enabled` - determines if you want to use Reachability metadata support or not (`true` by default)
* `version` - specifies exact Reachability metadata version you want to use
* `uri` - specifies the url where the metadata is stored. This can be used to point to the local repository. If not set, it defaults to metadata which is shipped inside the Native Build Tools.

You can read more about __Reachability metadata support__ and other (advanced) configuring options, https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#_configuring_the_metadata_repository[here].

In some cases, when you want to maintain multiple projects that share common metadata from various libraries, you should consider contributing metadata to https://github.com/oracle/graalvm-reachability-metadata[Reachability metadata project].
https://github.com/oracle/graalvm-reachability-metadata/blob/master/CONTRIBUTING.md[Contributing to the repository] should be simple:

- Clone repository locally:

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
git clone git@github.com:oracle/graalvm-reachability-metadata.git
----

- generate metadata and test stubs (replace with the GAV coordinates of library you are providing metadata for):

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
./gradlew scaffold --coordinates com.example:my-library:1.0.0
----

- implement tests in test stubs that will show how you have generated metadata
- collect metadata as described https://github.com/oracle/graalvm-reachability-metadata/blob/master/docs/CollectingMetadata.md#collecting-metadata-for-a-library[here]
- create a pull request and fill the checklist

[[track-diagnostics]]
== Using diagnostics

If you want to explore details about native images you are generating, you can add:

For GraalVM versions starting from GraalVM for JDK 23:

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
buildArgs.add("--emit build-report")
----

For older GraalVM versions (starting from GraalVM for JDK 21):

[source,bash,subs="verbatim,attributes", role="multi-language-sample"]
----
buildArgs.add("-H:+BuildReport")
----

When the Native Image build is completed, you will find a path to the generated Build Report HTML in `Build artifacts` section in the build output like this:
```
------------------------------------------------------------------------------------
Build artifacts:
/tmp/build/native/nativeCompile/main (executable)
/tmp/build/native/nativeCompile/main-build-report.html (build_info)
====================================================================================
```
You can read more about build report features https://www.graalvm.org/latest/reference-manual/native-image/overview/build-report/[here].

[NOTE]
Note that Build Report features vary depending on a GraalVM version you use.

[[example]]
== Example

Whole guide has been tested on the following test class:

[source,java,subs="verbatim,attributes", role="multi-language-sample"]
----
import org.junit.jupiter.api.Test;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class NativeTests {

    private static final List<String> resources = List.of("/TestResource.txt");

    @Test
    public void resourceTest() {
        try (InputStream is = NativeTests.class.getResourceAsStream(resources.get(0))) {
            if (is != null) {
                var reader = new BufferedReader(new InputStreamReader(is));
                reader.lines().forEach(System.out::println);
            } else {
                throw new IOException("Cannot read content of: " + resources.get(0));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static class Person {
        private String name;
        private String surname;
    }

    @Test
    public void reflectionTest() {
        Object person = new Person();
        Field[] fields = person.getClass().getDeclaredFields();
        List<String> actualFieldNames = Arrays.stream(fields).map(Field::getName).toList();

        assertTrue(actualFieldNames.containsAll(Arrays.asList("name", "surname")));
    }
}
----
